
<div id="linegraph"></div>
{% include 'download.html.twig' %}
<script>
    //I increased the bottom margin a little bit because the x label is tied to it; so I could lower the x label a little bit
    var margin = {top: 35, right: 20, bottom: 70, left: 90},
        width = 960 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

    var x = d3.time.scale()
        .range([0, width]);

    var y = d3.scale.linear()
        .range([height, 0]);

    var xAxis = d3.svg.axis()
        .scale(x)
        .ticks(d3.time.months,1)
        //makes the xAxis ticks a little longer than the xMinorAxis ticks
        .tickSize(15)
        .orient("bottom")
        .tickFormat(d3.time.format("%d %b %Y"));

    var xMinorAxis = d3.svg.axis()
        .scale(x)
        .ticks(d3.time.days,1)
        .orient("bottom");

    var xMajorAxis = d3.svg.axis()
        .scale(x)
        .ticks(d3.time.months,1)
        .tickSize(15)
        .orient("bottom");

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")
        .tickFormat(d3.format("d"));

    var line = d3.svg.line()
        .x(function(d) { return x(d.date); })
        .y(function(d) { return y(d.value); });

    var div = d3.select("#linegraph").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

    var svg = d3.select("#linegraph").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


    //format for tooltip
    //https://github.com/mbostock/d3/wiki/Time-Formatting
    //var formatTime = d3.time.format("%e %b");
    var formatTime = d3.time.format("%d %b %Y");

    // function for the y grid lines
    function make_y_axis() {
        return d3.svg.axis()
            .scale(y)
            .orient("left")
    }

    //The format in the CSV, which d3 will read
    data = d3.csv.parse("{{ report.data|raw }}", function(d) {
        return {
            date:d.date,
            value:+d.value
        };
    });

    var parseDate = d3.time.format("%Y-%m-%d %X");
    data.forEach(function(d) {
        d.date = parseDate.parse(d.date);
        d.value = +d.value;
    });
    var maxValue = 0;
    for (var i = 0; i < data.length; i++) {
        if(data[i].value > maxValue)
            maxValue = data[i].value;
    }

    //using imported data to define extent of x and y domains
    x.domain(d3.extent(data, function(d) { return d.date; }));
    y.domain([0, (maxValue + 100) * 12 / 10]);

// Draw the y Grid lines
    svg.append("g")
        .attr("class", "grid")
        .call(make_y_axis()
            .tickSize(-width, 0, 0)
            .tickFormat("")
        );

    svg.append("path")
        .datum(data)
        .attr("class", "line")
        .attr("d", line);

//taken from http://bl.ocks.org/mbostock/3887118
//and http://www.d3noob.org/2013/01/change-line-chart-into-scatter-plot.html
//creating a group(g) and will append a circle and 2 lines inside each group
    var g = svg.selectAll()
        .data(data).enter().append("g");

    //The markers on the line
    g.append("circle")
    //circle radius is increased
        .attr("r", 4.5)
        .attr("cx", function(d) { return x(d.date); })
        .attr("cy", function(d) { return y(d.value); });

    //The horizontal dashed line that appears when a circle marker is moused over
    g.append("line")
        .attr("class", "x")
        .attr("id", "dashedLine")
        .style("stroke", "steelblue")
        .style("stroke-dasharray", "3,3")
        .style("opacity", 0)
        .attr("x1", function(d) { return x(d.date); })
        .attr("y1", function(d) { return y(d.value); })
        .attr("x2", function(d) { return 0; })
        .attr("y2", function(d) { return y(d.value); });

    //The vertical dashed line that appears when a circle marker is moused over
    g.append("line")
        .attr("class", "y")
        .attr("id", "dashedLine")
        .style("stroke", "steelblue")
        .style("stroke-dasharray", "3,3")
        .style("opacity", 0)
        .attr("x1", function(d) { return x(d.date); })
        .attr("y1", function(d) { return y(d.value); })
        .attr("x2", function(d) { return x(d.date); })
        .attr("y2", height);

    //circles are selected again to add the mouseover functions
    g.selectAll("circle")
        .on("mouseover", function(d) {
            div.transition()
                .duration(200)
                .style("opacity", .9);
            div.html(d.value + "<br/>" + formatTime(d.date))
                .style("left", (d3.event.pageX - 20) + "px")
                .style("top", (d3.event.pageY + 6) + "px");
            //selects the horizontal dashed line in the group
            d3.select(this.nextElementSibling).transition()
                .duration(200)
                .style("opacity", .9);
            //selects the vertical dashed line in the group
            d3.select(this.nextElementSibling.nextElementSibling).transition()
                .duration(200)
                .style("opacity", .9);
        })

        .on("mouseout", function(d) {
            div.transition()
                .duration(500)
                .style("opacity", 0);

            d3.select(this.nextElementSibling).transition()
                .duration(500)
                .style("opacity", 0);

            d3.select(this.nextElementSibling.nextElementSibling).transition()
                .duration(500)
                .style("opacity", 0);
        });

    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis)
        .selectAll(".tick text")
        .call(wrap, 50);

    svg.append("g")
        .attr("class","xMinorAxis")
        .attr("transform", "translate(0," + height + ")")
        .style({ 'stroke': 'Black', 'fill': 'none', 'stroke-width': '1px'})
        .call(xMinorAxis)
        .selectAll("text").remove();

    svg.append("g")
        .attr("class","xMajorAxis")
        .attr("transform", "translate(0," + height + ")")
        .style({ 'stroke': 'Black', 'fill': 'none', 'stroke-width': '1px'})
        .call(xMajorAxis)
        .selectAll("text").remove();

//http://www.d3noob.org/2012/12/adding-axis-labels-to-d3js-graph.html
    svg.append("text")      // text label for the x-axis
        .attr("x", width / 2 )
        .attr("y",  height + margin.bottom)
        .style("text-anchor", "middle")
        .text("Datum");

    svg.append("text")      // text label for the y-axis
        .attr("y",30 - margin.left)
        .attr("x",50 - (height / 2))
        .attr("transform", "rotate(-90)")
        .style("text-anchor", "end")
        .style("font-size", "16px")
        .text({{ report.header|json_encode|raw }});

    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);
    //text label for the y-axis inside chart
    /*
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .style("font-size", "16px")
      .style("background-color","red")
      .text("road length (km)");
    */

//http://bl.ocks.org/mbostock/7555321
//This code wraps label text if it has too much text
    function wrap(text, width) {
        text.each(function() {
            var text = d3.select(this),
                words = text.text().split(/\s+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                y = text.attr("y"),
                dy = parseFloat(text.attr("dy")),
                tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                if (tspan.node().getComputedTextLength() > width) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                }
            }
        });
    }

//    });
</script>
